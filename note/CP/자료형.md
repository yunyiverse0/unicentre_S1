#[ 자료형 변환 ]
:자료형()

#[ 원소 추가 및 수정 ]
##< list > (순서O, 수정O) 
- 추가
  1. append(): 맨 마지막에 value 추가 
  2. insert(index, valuse): 원하는 위치에 value 추가 ( 인덱스로 위치 표현 )
  3. extand( [value1, value2] ): 여러 개의 value 추가

- 수정
- 삭제
  1. 값 삭제: lst.remove(값)
  2. 인덱스로 삭제: lst.pop(인덱스) / del lst[인덱스]
  3. 여러 개 삭제: del lst[1:4] #index 1-3 삭제
  4. 전체 삭제: lst.clear()

<hr>

##< set > (순서X, 수정O)
- 추가
  1. set.add(): 값 하나 추가
  2. set.update( [value1, value2] ): 여러 개의 값 추가

- 집합
  1.합집합 (Union)
    - a | b
    - a.union(b): 매소드
    - a |= b: in-place (a 바로 변경)
  2.  교집합 (Intersection)
    - a & b: 공통된 원소들만 뽑기
    - a.intersection(b): 매소드
    - a &= b: in-place (a 바로 변경)
  3. 차집합 (Difference)
    - a - b
    - a.difference(b): 매소드
    - a -= b: in-place (a 바로 변경)

- 수정
- 삭제
  1. 값 삭제: set.remove(x) -> 값 없으면 오류 / set.discard(x) -> 값 없으면 그냥 지나감
  2. 아무거나 하나 삭제: s.pop()
  3. 여러개 삭제: s -= {1, 2, 3} -> 차집합 사용
  4. 전체 삭제: s.clear()

<hr>

##< dictionary > (key:value)
- 추가
  1. 새로운 key를 추가하면서 새로운 value 추가: dict['a'] = 10
  2. 여러 개의 값 추가: dict.update( {'b':30, 'c':40} )

- 수정
  1. value 수정: dict['a'] = 20

- 삭제
  1. 단일 값 삭제(key 삭제): del d['a'] / d.pop('a')
  2. 전체 삭제: d.clear()

<hr>

##< tuple >
- 추가 / 수정
:immutable 이라서 추가 불가능
  1. list자료형으로 변환
  2. 값 추가 및 수정
  3. 값이 추가/수정된 list를 tuple로 변환

